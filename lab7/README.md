# lab7

## Intro
    RSM（复制状态机） 一个master 一堆replicas ，master负责从client接受命令然后在所有replicas上执行，必须要确保顺序一致，结果一致
    利用lab6实现的paxos算法来保证node的failed和re-join

    给每个请求分配viewStamp<view number(from paxos),squence number>保证顺序

    rpc服务要非阻塞

## Start
    1.rsm-client同lock client等，通信中的一层包装
    2.所有的server类，都用rsm代替，因为服务器不再是一台，而是多台需要复制状态
```
首先，当主节点处于稳定状态时，它可以处理来自 RSM 客户端的调用（invoke）RPC。对于每个请求，主节点会为其分配下一个视图戳（viewstamp）号，该号码具有递增的序号（seqno）。然后，主节点会在当前视图中的所有副本上发出一个调用（invoke）RPC。副本会对请求进行解组（unmarshall），并执行已注册的处理程序。请注意，副本必须按照请求的视图戳所指示的相同的总序（total order）来执行请求，并且序号（seqno）不能有任何间隙。如果主节点成功在所有副本（包括自身）上执行了请求，它将向客户端发送回复。如果主节点在此过程中遇到副本故障，它应该指示其配置对象启动视图更改（view change）。

偶尔，RSM 客户端可能会将其请求发送到非主节点，此时该节点应该通过回复 rsm_client_protocol::NOTPRIMARY 来拒绝客户端的请求。客户端随后将调用 members RPC 来获取更新后的副本列表。
```

```


关于复制状态机（Replicated State Machine，RSM）的情况。让我们逐一解释关键概念：

失败的副本重新加入运行中的RSM：在一个复制状态机环境中，多个副本（即服务器或节点）共同维护一个状态。如果某个副本因为故障而暂时脱离了系统，当它修复后重新加入，它的状态可能会落后于其他副本。

状态传输：为了同步其状态并与其他副本保持一致，重新加入的副本需要进行状态传输。这意味着它需要获取从其离开到重新加入期间发生的所有更改。

处理客户端请求时的复杂性：在复制状态机中，客户端的请求通常会被多个副本处理。如果在处理这些请求的过程中，主节点（控制节点）遇到故障，可能会导致一些副本已经执行了请求，而其他副本尚未执行。

状态同步：为了确保所有副本都能正确处理客户端请求，它们需要从一个公认的主节点同步状态。这样可以确保所有副本都有相同的数据和状态信息。

rsm_state_transfer.h：这可能是一个提供了状态同步相关功能的代码文件或接口。代码的“骨架”可能意味着提供了基本的结构和功能，但需要进一步开发以适应具体的系统和需求。
```

## Step 1
### 死锁问题
```
1.不要在rpc中调rpc（在后台线程中调用rpc）

```
### 主节点故障问题
```
为了处理主服务器故障，客户端应为所有请求分配序列号。也就是说，每个请求应该有一个唯一的客户端ID（例如，一个随机数或ID字符串）和一个序列号。对于acquire操作，客户端选择第一个未使用的序列号，并将该序列号作为参数提供给acquire RPC，同时携带客户端ID。与第四实验类似，您可能希望在尚未完成的acquire请求之前不向服务器发送额外的相同锁的acquire请求。对应的release操作（可能会延迟很长时间，因为锁被缓存）应该携带与最后一个acquire请求相同的序列号，以便服务器可以确定与该release操作对应的acquire请求。这种方法要求服务器每个客户端每个锁最多记住一个序列号。服务器应该丢弃过时的请求，但如果请求是来自同一客户端的最新请求的重复，则必须始终给予一致的响应。

使用这种客户端和服务器之间的序列号和客户端ID的机制，可以确保在主服务器故障时客户端能够跟踪其请求的状态，并在需要时与服务器进行一致的通信。这样可以提高协议的可靠性和一致性。
```
### 一致性问题
```text
在没有故障的情况下，缓存锁服务器的状态应该保持一致。这个要求有两个含义。首先，应用到所有副本的输入应该以相同的方式改变状态。其次，只应用于主服务器的输入不应改变主服务器的状态。这样的输入包括revoke或retry RPC的响应，因为只有主服务器能够向客户端发送RPC并接收客户端的RPC响应。

确保状态一致性的关键是确保所有副本的状态变化是相同的。这可以通过使用一致的复制协议来实现，例如Paxos或Raft。这些协议确保所有副本按照相同的顺序接收和应用输入操作，从而保持状态的一致性。

另一个重要的设计考虑是区分主服务器和其他副本之间的操作。对于只应用于主服务器的操作，可以通过在服务器之间进行通信来确保仅主服务器执行这些操作，而其他副本不会进行相应的状态更改。
```
```
第一挑战：避免由RSM层持有的锁引起的死锁
问题：RSM层在调用SVR_HDL（服务器处理程序）时持有invoke_mutex，以保证RPC请求的顺序执行。这意味着缓存锁服务器在同一时间只能处理一个RPC请求，可能导致死锁。

解决方案：

避免在RPC处理程序中直接调用RPC：这意味着不在SVR_HDL或CLT_HDL（客户端处理程序）中直接发送RPC。相反，应使用后台线程来发送RPC。
使用后台线程：提供了retryer和revoker两个后台线程在lock_server_cache_rsm中，以及一个releaser线程在lock_client_cache_rsm中。这些线程可以处理RPC调用，而不会直接占用RPC处理程序。
第二挑战：SVR_HDL不应等待另一个RPC请求的到来
问题：在之前的设计中，锁服务器可能发送吊销请求给锁拥有者，并等待拥有者发送释放RPC回服务器，这在新的设计中可能导致死锁。

解决方案：SVR_HDL应避免等待其他RPC请求的到来。相反，它应该立即完成其操作，并且任何需要等待的操作都应该移到后台线程中去处理。

第三挑战：处理主锁服务器的失败
问题：如果主锁服务器失败，客户端可能不确定其未完成的RPC请求是否被新的主服务器处理了。

解决方案：客户端应为所有请求分配序列号。

请求唯一性：每个请求都应有一个唯一的客户端ID和序列号。
请求和响应的一致性：例如，释放锁的请求应携带与最后一个获得锁的请求相同的序列号，以便服务器能够识别哪个请求对应哪个释放。
处理重复请求：服务器应丢弃过时的请求，但对最新的重复请求保持一致的响应。
第四挑战：确保没有失败时锁服务器的状态一致性
问题：确保在没有故障的情况下，缓存锁服务器的状态保持一致。

解决方案：

对所有副本应用的输入应相同地改变状态：确保所有副本对相同输入的响应
是一致的。

只对主副本应用的输入不应改变主副本状态：确保像吊销或重试RPC这样的操作，虽然只有主副本能发送RPC到客户端并接收来自客户端的响应，但这些操作不应改变主副本的状态。这样可以维持所有副本的状态一致。
综合解决方案
这些挑战要求设计一个复杂的锁协议和对应的服务器/客户端实现，它们必须能够在分布式环境中可靠地工作，并且能够处理故障和一致性问题。具体包括：

使用后台线程来处理可能导致死锁的RPC调用。
避免在锁的RPC处理程序中等待其他RPC请求的到来。
通过为每个请求分配序列号，确保处理主服务器故障的情况。
确保在没有故障时，所有副本的状态保持一致。
```

## Step 2&3

### 主要流程
```
1.客户端向主服务器发送请求。invoke rpc
2.主服务器分配视图戳，并将请求发送给所有从服务器。
3.从服务器根据视图戳执行请求，并向主服务器回复 OK。
4.主服务器在本地执行请求，并将结果回复给客户端。
```

### 